#!/usr/bin/env node

import { Command } from "commander";
import * as fs from "fs-extra"; // Use fs-extra for convenience (ensure installed)
import * as path from "path";
import * as ejs from "ejs";
import { execSync } from "child_process";

// Helper function to convert kebab-case to PascalCase
function kebabToPascalCase(str: string): string {
  return str
    .split("-")
    .map((word) => word.charAt(0).toUpperCase() + word.slice(1))
    .join("");
}

// Helper function to validate plugin name
function isValidPluginName(name: string): boolean {
  // Basic check: kebab-case, alphanumeric, starts with letter
  return /^[a-z][a-z0-9-]*$/.test(name);
}

async function generatePlugin(pluginName: string, options: any) {
  console.log(`Generating plugin: ${pluginName}`);
  console.log("Options:", options);

  if (!isValidPluginName(pluginName)) {
    console.error(
      "Error: Invalid plugin name. Must be kebab-case, alphanumeric, and start with a letter."
    );
    process.exit(1);
  }

  const targetDir = path.resolve(process.cwd(), pluginName); // Generate in current dir
  const templateDir = path.resolve(__dirname, "../templates", options.template);
  const pluginId = pluginName;
  const pluginComponentName = `${kebabToPascalCase(pluginName)}Component`;
  const pluginDescription = `Plugin ${pluginName} generated by the toolkit`;

  if (fs.existsSync(targetDir)) {
    console.error(`Error: Directory ${targetDir} already exists.`);
    process.exit(1);
  }

  console.log(`Creating directory ${targetDir}...`);
  fs.ensureDirSync(targetDir);

  console.log(`Copying template files from ${templateDir}...`);

  const templateData = {
    pluginId: pluginId,
    pluginName: pluginName,
    pluginComponentName: pluginComponentName,
    pluginDescription: pluginDescription,
    includeFrontend: options.frontend,
    includeBackend: options.backend,
  };

  // Recursively copy and process templates
  async function processDirectory(source: string, destination: string) {
    const entries = fs.readdirSync(source, { withFileTypes: true });
    for (const entry of entries) {
      const sourcePath = path.join(source, entry.name);
      const isTemplateFile = entry.name.endsWith(".ejs");
      const baseName = entry.name.replace(".ejs", "");
      const targetName = baseName.replace(
        "<%= pluginComponentName %>",
        pluginComponentName
      );
      const destinationPath = path.join(destination, targetName);

      // --- Conditional Skipping Logic ---
      // Skip frontend-specific directories/files
      if (!options.frontend) {
        if (entry.isDirectory() && ["client", "components"].includes(baseName))
          continue;
        if (entry.isFile() && baseName === "webpack.config.js") continue;
        if (entry.isFile() && sourcePath.includes(path.join("src", "client")))
          continue; // Skip files in src/client
        if (
          entry.isFile() &&
          sourcePath.includes(path.join("src", "components"))
        )
          continue; // Skip files in src/components
      }
      // Skip backend-specific directories/files
      if (!options.backend) {
        if (
          entry.isFile() &&
          baseName === "index.ts" &&
          sourcePath.endsWith(path.join("src", "index.ts.ejs"))
        )
          continue; // Skip top-level src/index.ts
        // Add more backend skips if necessary (e.g., specific backend dirs)
      }
      // ----------------------------------

      if (entry.isDirectory()) {
        fs.ensureDirSync(destinationPath);
        await processDirectory(sourcePath, destinationPath); // Recurse
      } else if (entry.isFile()) {
        if (isTemplateFile) {
          const templateContent = fs.readFileSync(sourcePath, "utf-8");
          const renderedContent = ejs.render(templateContent, templateData);
          fs.writeFileSync(destinationPath, renderedContent);
        } else {
          // Just copy non-template files
          fs.copyFileSync(sourcePath, destinationPath);
        }
      }
    }
  }

  await processDirectory(templateDir, targetDir);

  console.log("Template files copied and processed.");

  // Install dependencies
  console.log("Installing dependencies...");
  try {
    execSync("npm install", { cwd: targetDir, stdio: "inherit" });
    console.log("Dependencies installed successfully.");
  } catch (error) {
    console.error("Error installing dependencies:", error);
    console.log("Please run `npm install` manually in the plugin directory.");
  }

  console.log(`\nPlugin ${pluginName} created successfully in ${targetDir}`);
  console.log("Next steps:");
  console.log(` cd ${pluginName}`);
  console.log(" npm run watch  (to start development build)");
}

const program = new Command();

program
  .name("generate-ssm-plugin") // Match the bin name
  .description("CLI tool to generate Squirrel Servers Manager plugins")
  .version("0.0.1"); // TODO: Read from package.json?

program
  .command("create-plugin")
  .description("Create a new plugin structure")
  .argument("<plugin-name>", "Name of the plugin to create (kebab-case)")
  .option(
    "--template <template-name>",
    "Select plugin template (e.g., basic)",
    "basic"
  )
  .option("--no-frontend", "Exclude frontend components") // Use commander's --no- prefix
  .option("--no-backend", "Exclude backend components") // Use commander's --no- prefix
  .action(generatePlugin);

program.parse(process.argv);
